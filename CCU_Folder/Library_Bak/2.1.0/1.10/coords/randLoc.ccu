//(Randomized Location)

//== Credits
Ideas from:
	Shane Stone for providing the basis on how everything is done
		-The main difference with this version is that it randomizes properly, since each row has an equal chance of being chosen regardless of the number of blocks
		-This is done by admittedly taking up more resources, but it is more random and allows for empty rows when the other one couldn't
	Shane Stone's Youtube Channel: https://www.youtube.com/user/shanewolf38/featured
	Shane Stone's Video explanation: https://www.youtube.com/watch?v=9jZpheCdkqM
=//

//<Imports
IMPORT {LIBRARY v2/checkImport.ccu}
CCU.checkImport(ISIMPORT;coords/randLoc)

IMPORT {LIBRARY v2/1.10/general/utils.ccu}
IMPORT {LIBRARY v2/1.10/general/varUtils.ccu}
IMPORT {LIBRARY v2/1.10/math/rand.ccu}
//>

//<Usage
//=
DEF $StyleOption$ +X
DEF COORDS $CoordsOption$ 233 7 174
DEF $BlockOption$ stonebrick 0

OPTIONS:
	blockOption $BlockOption$
	coordsOption $CoordsOption$
	styleOption $StyleOption$ 16
	parseOption true
	commandOption true
	combinerOption true
	parseChangesOption false
		
FUNC {TEMP ACTIVATE CCU.coords.randLoc.init(type;ARGS) ARGS}:
	DEF COORDS $randLocRegion$ 260 4 181 285 12 217
	DEF COORDS $randLocOffset$ ~ ~ ~
	DEF $randLocBlockDetect$ stone 1
	DEF $randLocBlockTemp$ stone 2
	DEF $randLocDetectAll$ true
	
	DEF $randLocObjConst$ Number
	DEF $randLocObjTot$ CCURLnt
	DEF $randLocObjAffectedBlocks$ CCURLab
	DEF $randLocObjTeleNum$ CCURLtn
	DEF $randLocObjRand$ CCURLrd
	DEF $randLocObjCalc$ CCURLcl
	DEF $randLocObjChooseNum$ CCURLcn
	
	ARRAY {Arr_randLocCloudTags}:
		CCURandLocCloud
		
	ARRAY {Arr_randLocStandTags}:
		CCURandLocStand
	

CCU.coords.randLoc.cmdInit(type)
CCU.coords.randLoc.cmdInitClock(type)
CCU.coords.randLoc.cmdUpdate(type)
CCU.coords.randLoc.cmdMain(type;selector)
=//
//>

//<Initialize
FUNC {PARSESEP CCU.coords.randLoc.init}:
	IF {|1| != ``}:
		|1|()
		UNASSIGN {FUNC |1|}
	
	ARRAY {TEMP ACTIVATE CCU.varsInit(ARGS;false) ARGS}:
		COORDS `$randLocRegion$` 260 4 181 285 12 217 /// northwest corner
		COORDS `$randLocOffset$` ~ ~ ~
		`$randLocBlockDetect$` stone 1
		`$randLocBlockTemp$` stone 2
		`$randLocDetectAll$` false
		
		`$randLocObjConst$` Number
		`$randLocObjTot$` CCURLnt
		`$randLocObjAffectedBlocks$` CCURLab
		`$randLocObjTeleNum$` CCURLtn
		`$randLocObjRand$` CCURLrd
		`$randLocObjCalc$` CCURLcl
		`$randLocObjChooseNum$` CCURLcn
		`$randLocObjPrevious$` CCURLpv
		
	ARRAY {TEMP ACTIVATE CCU.arraysInit(ARGS;false) ARGS}:
		Arr_randLocCloudTags CCUrandLocCloud
		Arr_randLocStandTags CCUrandLocStand
	
	ARRAY {GLOBAL Arr_CCUcoordsRandLocVars}:
		COORDS `$randLocRegion$`
		COORDS `$randLocOffset$`
		`$randLocBlockDetect$`
		`$randLocBlockTemp$`
		`$randLocDetectAll$`

		`$randLocObjConst$`
		`$randLocObjTot$`
		`$randLocObjAffectedBlocks$`
		`$randLocObjTeleNum$`
		`$randLocObjRand$`
		`$randLocObjCalc$`
		`$randLocObjChooseNum$`
		`$randLocObjPrevious$`
		
	ARRAY {GLOBAL Arr_CCUcoordsRandLocArrays}:
		Arr_randLocCloudTags
		Arr_randLocStandTags
		
	DEF GLOBAL |0|.$randLocStandTrue$ @e[type=ArmorStand,Arr_randLocStandTags[0],$randLocObjTeleNum$>=0]
	DEF GLOBAL |0|.$randLocStandFalse$ @e[type=ArmorStand,Arr_randLocStandTags[0],$randLocObjTeleNum$=-1]
	
	CCU.setClassVars(Arr_CCUcoordsRandLocVars;|0|)
	CCU.setClassArrays(Arr_CCUcoordsRandLocArrays;|0|)
	
	FUNC {TEMP ACTIVATE CCU.math.rand.init(|0|;ARGS) ARGS}:
		DEF $randDynamicMin$ false
		DEF $randDynamicMax$ true
		DEF $randMin$ 1
		DEF $randMax$ 0
		DEF $randObj$ $randLocObjRand$
		DEF $randObjConst$ $randLocObjConst$
	
///	CCU.math.rand.init(|0|)
//>

//<Command Initialize
FUNC {CCU.coords.randLoc.cmdInit}:
	CCU.useClassVars(Arr_CCUcoordsRandLocVars;|0|)
	CCU.useClassArrays(Arr_CCUcoordsRandLocArrays;|0|)
	
	ARRAY {GLOBAL ACTIVATE CCU.objectiveAdd(Obj_coords.randLoc) Obj_coords.randLoc}:
		$randLocObjTot$ dummy Location Number Total
		$randLocObjAffectedBlocks$ dummy Location Affected Blocks
		$randLocObjTeleNum$ dummy Location Teleport Number
		$randLocObjRand$ dummy Location Random
		$randLocObjCalc$ dummy Location Calc
		$randLocObjChooseNum$ dummy Location Choose Num
		$randLocObjPrevious$ dummy Location Choose Previous AB
		
	CCU.setConstants($randLocObjConst$;true;-1)
	
	summon ArmorStand $randLocRegion$[x, y, z] {Tags:["LocationEntity","Arr_randLocStandTags[0]"],Invulnerable:1,PersistenceRequired:1,Marker:1,NoGravity:1,Invisible:1}
	@e[type=ArmorStand,Arr_randLocStandTags[0]] $randLocObjAffectedBlocks$ = 0
	@e[type=ArmorStand,Arr_randLocStandTags[0]] $randLocObjTeleNum$ = 0
	@e[type=ArmorStand,Arr_randLocStandTags[0]] stats entity @e[c=1,type=ArmorStand,Arr_randLocStandTags[0]] set AffectedBlocks \
			@e[c=1,type=ArmorStand,Arr_randLocStandTags[0]] $randLocObjAffectedBlocks$
	CCU.math.rand.cmdInit(|0|)
///	ScSS $randLocObjRand$
	
	CCU.unuseClassVars(Arr_CCUcoordsRandLocVars)
	CCU.unuseClassArrays(Arr_CCUcoordsRandLocArrays)
//>

//<Summon Counter Testfor Clock
FUNC {CCU.coords.randLoc.cmdInitClock}:
	CCU.useClassVars(Arr_CCUcoordsRandLocVars;|0|)
	CCU.useClassArrays(Arr_CCUcoordsRandLocArrays;|0|)
	
	testfor @e[type=ArmorStand,Arr_randLocStandTags[0],$randLocObjTeleNum$>=0]
	CCU_SetblockTestfor
	
	@e[type=ArmorStand,Arr_randLocStandTags[0],$randLocObjTeleNum$>=0] summon AreaEffectCloud ~ ~ ~ {Tags:["LocationEntity","Arr_randLocCloudTags[0]"],$Duration$}
	
	/// initialize $randLocObjTot$
	@e[type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjTot$ + 0
	
	/// initialize $randLocObjAffectedBlocks$
	@e[type=AreaEffectCloud,Arr_randLocCloudTags[0],$randLocObjTot$=0] $randLocObjAffectedBlocks$ + 0
	
	/// initialize $randLocObjAffectedBlocks$ stats
	@e[type=AreaEffectCloud,Arr_randLocCloudTags[0],$randLocObjTot$=0] stats entity @e[c=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] set AffectedBlocks \
			@e[c=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjAffectedBlocks$
	
	/// gets the number of granite in the row
	@e[type=AreaEffectCloud,Arr_randLocCloudTags[0],$randLocObjTot$=0] fill ~ ~ ~ ~$randLocRegion$[2x - x] ~$randLocRegion$[2y - y] ~ $randLocBlockDetect$ replace $randLocBlockTemp$
	
	/// removes the cloud if there are no granite if randLocDetectAll is true
	IF {randLocDetectAll != true}:
		kill @e[type=AreaEffectCloud,Arr_randLocCloudTags[0],$randLocObjTot$=0,$randLocObjAffectedBlocks$=0]
	
	/// adds to the total
	ScOP Max $randLocObjRand$ += @e[type=AreaEffectCloud,Arr_randLocCloudTags[0],$randLocObjTot$=0] $randLocObjAffectedBlocks$
	
	/// sets the cloud to the current total
	ScOP @e[type=AreaEffectCloud,Arr_randLocCloudTags[0],$randLocObjTot$=0] $randLocObjTot$ = Max $randLocObjRand$
	
	@e[type=ArmorStand,Arr_randLocStandTags[0],$randLocObjTeleNum$>=0] $randLocObjTeleNum$ + 1 /// adds the row number
	tp @e[type=ArmorStand,Arr_randLocStandTags[0],$randLocObjTeleNum$>=0] ~ ~ ~1 /// teleports one to the -Z
	
///	Assuming that the armor stand has reached the max row number:
	@e[type=ArmorStand,Arr_randLocStandTags[0],$randLocObjTeleNum$=$randLocRegion$[2z - z + 1]] ScOP Max $randLocObjRand$ = \
			@e[type=ArmorStand,Arr_randLocStandTags[0],$randLocObjTeleNum$=$randLocRegion$[2z - z + 1]] $randLocObjTot$ /// Sets the max number in $randLocObjRand$ as the number of granite
	@e[type=ArmorStand,Arr_randLocStandTags[0],$randLocObjTeleNum$=$randLocRegion$[2z - z + 1]] fill $randLocRegion$ $randLocBlockTemp$ replace $randLocBlockDetect$ /// Resets all stone
	@e[type=ArmorStand,Arr_randLocStandTags[0],$randLocObjTeleNum$=$randLocRegion$[2z - z + 1]] $randLocObjTeleNum$ = -1 /// Sets $randLocObjTeleNum$ to -1
	
	CCU.unuseClassVars(Arr_CCUcoordsRandLocVars)
	CCU.unuseClassArrays(Arr_CCUcoordsRandLocArrays)
//>

//<Update Selection
FUNC {CCU.coords.randLoc.cmdUpdate}:
///	Note that adding new blocks to lanes that don't have granite will not work since the areaeffectcloud won't be summoned

	CCU.useClassVars(Arr_CCUcoordsRandLocVars;|0|)
	CCU.useClassArrays(Arr_CCUcoordsRandLocArrays;|0|)
	
	@e[type=AreaEffectCloud,Arr_randLocCloudTags[0]] ScOP @e[c=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjPrevious$ = \
			@e[c=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjAffectedBlocks$ /// stores the value of randLocObjAffectedBlocks
	
	@e[type=AreaEffectCloud,Arr_randLocCloudTags[0]] fill ~ ~ ~ ~$randLocRegion$[2x - x] ~$randLocRegion$[2y - y] ~ $randLocBlockDetect$ replace $randLocBlockTemp$
	fill $randLocRegion$ $randLocBlockTemp$ replace $randLocBlockDetect$ /// Resets all stone
	
	@e[type=AreaEffectCloud,Arr_randLocCloudTags[0]] ScOP @e[c=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjCalc$ = \
			@e[c=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjAffectedBlocks$
	@e[type=AreaEffectCloud,Arr_randLocCloudTags[0]] ScOP @e[c=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjCalc$ -= \
			@e[c=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjPrevious$ /// calculating (current affectedblocks - previous affectedblocks)
	
	@e[type=AreaEffectCloud,Arr_randLocCloudTags[0]] ScOP @e[dz=$randLocRegion$[2z - z],type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjTot$ += \
			@e[c=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjCalc$ /// Adds to total in each cloud to the positive z direction (previous clouds aren't affected)
			
	Max $randLocObjRand$ = 0
	ScOP Max $randLocObjRand$ > * $randLocObjTot$ /// changes max to highest number in randLocObjTot
	
	CCU.unuseClassVars(Arr_CCUcoordsRandLocVars)
	CCU.unuseClassArrays(Arr_CCUcoordsRandLocArrays)
//>

//<General Scoreboard Clock
FUNC {CCU.coords.randLoc.cmdMain}:
	CCU.useClassVars(Arr_CCUcoordsRandLocVars;|0|)
	CCU.useClassArrays(Arr_CCUcoordsRandLocArrays;|0|)
	
/// testfor |1|
/// CCU_SetblockTestfor
///	//=
	USE {|1|}:
		CCU.math.rand.cmdMain(|1|;|0|)
///	=//
///	|1| $randLocObjRand$ = 6
	
	|1| stats entity @a[c=1] set AffectedBlocks @a[c=1] $randLocObjAffectedBlocks$
	tp |1| $randLocRegion$[x, y, z]
	|1| @e[type=AreaEffectCloud,Arr_randLocCloudTags[0]] ScOP @e[c=1,r=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjCalc$ = \
			@e[c=1,r=1,type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjTot$
	|1| ScOP @e[type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjCalc$ -= |1| $randLocObjRand$ /// creates the order of (min --> max)

/// reverses the order to (max --> min) whereas the first nonpositive integer is the row
	|1| ScOP @e[type=AreaEffectCloud,Arr_randLocCloudTags[0]] $randLocObjCalc$ *= -1 $randLocObjConst$

	
	|1| tp |1| @e[c=1,type=AreaEffectCloud,Arr_randLocCloudTags[0],$randLocObjCalc$<=0]
	|1| ScOP |1| $randLocObjChooseNum$ = @e[c=1,r=1,type=AreaEffectCloud,Arr_randLocCloudTags[0],$randLocObjCalc$<=0] $randLocObjCalc$ /// negative
	|1| ScOP |1| $randLocObjChooseNum$ += @e[c=1,r=1,type=AreaEffectCloud,Arr_randLocCloudTags[0],$randLocObjCalc$<=0] $randLocObjAffectedBlocks$ /// adds positive
///	|1| tp |1| ~ ~1 ~
	
	IF {$randLocRegion$[2y - y] > 0}:
		@e[type=ArmorStand,Arr_randLocStandTags[0]] $randLocObjTot$ = 0
		
		LOOP {0 $randLocRegion$[2y - y] + 1}:
			|1;1| summon AreaEffectCloud ~ ~|0| ~ {Tags:["CCUrandLocTemp"],Duration:2000}
			@e[type=AreaEffectCloud,CCUrandLocTemp] $randLocObjCalc$ + 0 /// initialize $randLocObjCalc$
			@e[type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] stats entity @e[c=1,type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] \
					set AffectedBlocks @e[c=1,type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] $randLocObjAffectedBlocks$ /// initialize affectedBlocks
			@e[type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] $randLocObjAffectedBlocks$ + 0
			@e[type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] \
					fill ~ ~ ~ ~$randLocRegion$[2x - x] ~ ~ $randLocBlockDetect$ replace $randLocBlockTemp$ /// gets the number of granite in the row (and then reset it)
					
			@e[type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] fill ~ ~ ~ ~$randLocRegion$[2x - x] ~ ~ $randLocBlockTemp$ replace $randLocBlockDetect$
			kill @e[type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0,$randLocObjAffectedBlocks$=0] /// removes the cloud if there are no granite
			
			ScOP @e[type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] $randLocObjTot$ = \
					@e[type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] $randLocObjAffectedBlocks$ /// adds to the total
					
			ScOP @e[type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] $randLocObjTot$ += \
					@e[type=ArmorStand,Arr_randLocStandTags[0]] $randLocObjTot$ /// adds from the armor stand total
					
			ScOP @e[type=ArmorStand,Arr_randLocStandTags[0]] $randLocObjTot$ = \
					@e[type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] $randLocObjTot$ /// adds to the armor stand total
			@e[type=AreaEffectCloud,CCUrandLocTemp,$randLocObjCalc$=0] $randLocObjCalc$ = 1
			
		|1| ScOP @e[type=AreaEffectCloud,CCUrandLocTemp] $randLocObjTot$ -= |1| $randLocObjChooseNum$ /// changes total because it will be removed instantly
		|1| ScOP @e[type=AreaEffectCloud,CCUrandLocTemp] $randLocObjTot$ *= -1 $randLocObjConst$ /// reverses the order
		|1| tp |1| @e[c=1,type=AreaEffectCloud,CCUrandLocTemp,$randLocObjTot$<=0]
		|1| ScOP |1| $randLocObjChooseNum$ = @e[c=1,r=1,type=AreaEffectCloud,CCUrandLocTemp,$randLocObjTot$<=0] $randLocObjTot$ /// negative
		|1| ScOP |1| $randLocObjChooseNum$ += @e[c=1,r=1,type=AreaEffectCloud,CCUrandLocTemp,$randLocObjTot$<=0] $randLocObjAffectedBlocks$ /// adds positive
		kill @e[type=AreaEffectCloud,CCUrandLocTemp]
	
	|1| $randLocObjAffectedBlocks$ = 0
	|1| $randLocObjCalc$ = 0
	
	LOOP {16 1 / 2}:
	/// fills with stone and replaces it back to update the 
		|1;1| fill ~ ~ ~ ~CALC(|0| - 1) ~ ~ $randLocBlockDetect$ replace $randLocBlockTemp$
		|1;1| fill ~ ~ ~ ~CALC(|0| - 1) ~ ~ $randLocBlockTemp$ replace $randLocBlockDetect$
		
		IF {|0| != 1}:
			|1;1| ScOP @a[c=1] $randLocObjCalc$ = @a[c=1] $randLocObjAffectedBlocks$
			|1;1| ScOP @a[c=1] $randLocObjAffectedBlocks$ -= @a[c=1] $randLocObjChooseNum$
			tp @a[$randLocObjAffectedBlocks$<=-1] ~|0| ~ ~
			@a[$randLocObjAffectedBlocks$<=-1] ScOP @a[c=1] $randLocObjChooseNum$ -= @a[c=1] $randLocObjCalc$
			
		ELSE:
			|1;1| ScOP @a[c=1] $randLocObjAffectedBlocks$ -= @a[c=1] $randLocObjChooseNum$
			tp @a[$randLocObjAffectedBlocks$<=-1] ~1 ~ ~
	
	|1| reset $randLocObjAffectedBlocks$
///	|1| $randLocObjChooseNum$ = 0
	stats entity |1| clear AffectedBlocks
	
	tp |1| $randLocOffset$[x, y + 1, z]
	
	CCU.unuseClassVars(Arr_CCUcoordsRandLocVars)
	CCU.unuseClassArrays(Arr_CCUcoordsRandLocArrays)
//>

//<General Scoreboard End
FUNC {CCU.coords.randLoc.cmdUninstall}:
	CCU.useClassVars(Arr_CCUcoordsRandLocVars;|0|)
	CCU.useClassArrays(Arr_CCUcoordsRandLocArrays;|0|)
	
	fill $randLocRegion$ $randLocBlockTemp$ replace $randLocBlockDetect$ /// Resets all stone
	
	CCU.objectiveRemove(Obj_coords.randLoc)
	kill @e[type=AreaEffectCloud,Arr_randLocCloudTags[0]]
	kill @e[type=ArmorStand,Arr_randLocStandTags[0]]
	
	CCU.unuseClassVars(Arr_CCUcoordsRandLocVars)
	CCU.unuseClassArrays(Arr_CCUcoordsRandLocArrays)
//>






