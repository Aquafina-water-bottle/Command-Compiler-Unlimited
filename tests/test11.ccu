//(Name)

//<General Definitions
DEF $CMDName$ Randomized_Location
DEF $CMDSizeX$ 16
DEF $CMDSizeY$ 16
DEF $CMDSizeZ$ 3

DEF $StyleOption$ +X
DEF COORDS $CoordsOption$ 233 7 174
DEF $BlockOption$ stonebrick 0

IMPORT {LIBRARY GETDIR 1.10/General}
IMPORT {LIBRARY 1.10/Math/random.ccu}

DEF COORDS $Corner$ 233 5 181

DEF $RowNumber$ 37
DEF $ColumnNumber$ 26

DEF $EntityType$ AreaEffectCloud

DEF COORDS $FillRegion$ 233 4 181 258 4 217
//>

//<Options
OPTIONS:
	blockOption $BlockOption$
	coordsOption $CoordsOption$
	styleOption $StyleOption$ 16
	parseOption true
	commandOption true
	combinerOption true
///	filePathFuncOption 
	parseChangesOption false
//>


//<Initialize
FUNC {CCU.coordinates.randLocInitialize}:
	ARGS()
	UNASSIGN {FUNC ARGS}
	
	IF {$CCUObjX$ = `$CCUObjX$`}:
		EXIT $CCUObjX$ must be defined when using CCU.coordinates.randLocInitialize
	
	IF {$CCUObjY$ = `$CCUObjY$`}:
		EXIT $CCUObjY$ must be defined when using CCU.coordinates.randLocInitialize
	
	IF {$CCUObjZ$ = `$CCUObjZ$`}:
		EXIT $CCUObjZ$ must be defined when using CCU.coordinates.randLocInitialize
	
	IF {$CCUObjTPX$ = `$CCUObjTPX$`}:
		EXIT $CCUObjTPX$ must be defined when using CCU.coordinates.randLocInitialize
	
	IF {$CCUObjTPY$ = `$CCUObjTPY$`}:
		EXIT $CCUObjTPY$ must be defined when using CCU.coordinates.randLocInitialize
	
	IF {$CCUObjTPZ$ = `$CCUObjTPZ$`}:
		EXIT $CCUObjTPZ$ must be defined when using CCU.coordinates.randLocInitialize
	
	IF {$CCUObjStats$ = `$CCUObjStats$`}:
		EXIT $CCUObjStats$ must be defined when using CCU.coordinates.randLocInitialize

	IF {Arr_CCUCloudTags[S] = `Arr_CCUCloudTags[S]`}:
		EXIT Arr_CCUCloudTags must be defined when using CCU.coordinates.randLocInitialize
	
	IF {$CCUFolderName$ = `$CCUFolderName$`}:
		DEF GLOBAL $CCUFolderName$ coordinates
	
	IF {$CCUNumber$ = `$CCUNumber$`}:
		DEF GLOBAL $CCUNumber$ Number
//>

//<General Scoreboard Start
FUNC {Func_GeneralScoreboardStart}:
	ARRAY {GLOBAL ACTIVATE CCU.objectiveAdd(Obj_GeneralScoreboardStart) Obj_GeneralScoreboardStart}:
		CCULCnu dummy Location Number
		CCULCnt dummy Location Number Total
		CCULCab dummy Location Affected Blocks
		CCULCtn dummy Location Teleport Number
		CCULCrd dummy Location Random
		CCULCcl dummy Location Calc
		CCULCcn dummy Location Choose Num
	
	ARRAY {ACTIVATE CCU.iterateNumbers() ARGS}:
		-1
		
	summon ArmorStand $Corner$[x, y - 1, z] {Tags:["LocationEntity","CCULocStand"],Invulnerable:1,PersistenceRequired:1,Marker:1,NoGravity:1}
	@a stats entity @a[c=1] set AffectedBlocks @a[c=1] CCULCab
	@e[type=ArmorStand,CCULocStand] CCULCab = 0
	@e[type=ArmorStand,CCULocStand] CCULCtn = 0
	@e[type=ArmorStand,CCULocStand] stats entity @e[c=1,type=ArmorStand,CCULocStand] set AffectedBlocks @e[c=1,type=ArmorStand,CCULocStand] CCULCab
	
	FUNC {ACTIVATE CCU.random.init(1;CCULCrd) ARGS}:
		DEF $CCUDynamicMin$ false
		DEF $CCUDynamicMax$ true
		DEF $CCURandMin$ 1
		DEF $CCURandMax$ 5
		
	ScSS CCULCrd
//>

//<Summon Counter Testfor Clock
FUNC {Func_SummonCounterTFClock}:
	testfor @e[type=ArmorStand,CCULocStand,CCULCtn>=0]
	CCU_SetblockTestfor
	
	@e[type=ArmorStand,CCULocStand,CCULCtn>=0] summon $EntityType$ ~ ~ ~ {Tags:["LocationEntity","CCULocCloud"],$Duration$}
	@e[type=$EntityType$,CCULocCloud] CCULCnt + 0 /// initialize CCULCnt
	@e[type=ArmorStand,CCULocStand,CCULCtn>=0] fill ~ ~ ~ ~CALC($ColumnNumber$ - 1) ~ ~ stone 1 replace stone 2 /// gets the number of granite in the row
	@e[type=ArmorStand,CCULocStand,CCULCtn>=0,CCULCab=0] kill @e[type=$EntityType$,CCULocCloud,CCULCnt=0] /// removes the cloud if there are no granite
	ScOP @e[type=$EntityType$,CCULocCloud,CCULCnt=0] CCULCnu += @e[type=ArmorStand,CCULocStand,CCULCtn>=0] CCULCab /// adds to the current number
	ScOP @e[type=ArmorStand,CCULocStand,CCULCtn>=0] CCULCnt += @e[type=ArmorStand,CCULocStand,CCULCtn>=0] CCULCab /// adds to the total
	ScOP @e[type=$EntityType$,CCULocCloud,CCULCnt=0] CCULCnt = @e[type=ArmorStand,CCULocStand,CCULCtn>=0] CCULCnt /// sets the cloud to the current total
	
	@e[type=ArmorStand,CCULocStand,CCULCtn>=0] CCULCtn + 1 /// adds the row number
	tp @e[type=ArmorStand,CCULocStand,CCULCtn>=0] ~ ~ ~1 /// teleports one to the -Z
	
///	Assuming that the armor stand has reached the max row number:
	ScOP Max CCULCrd = @e[type=ArmorStand,CCULocStand,CCULCtn=$RowNumber$] CCULCnt /// Sets the max number in CCULCrd as the number of granite
	@e[type=ArmorStand,CCULocStand,CCULCtn=$RowNumber$] fill $FillRegion$ stone 2 replace stone 1 /// Resets all stone
	@e[type=ArmorStand,CCULocStand,CCULCtn=$RowNumber$] CCULCtn = -1 /// Sets CCULCtn to -1
//>

//<General Scoreboard Clock
FUNC {Func_GeneralScoreboardClock}:
	testfor @a[Loc]
	CCU_SetblockTestfor
	
	FUNC {ARGS}:
		DEF $CCUDynamicMin$ false
		DEF $CCUDynamicMax$ true
		DEF $CCURandMin$ 1
	
	USE {@a[Loc]}:
		CCU.random.main(1;CCULCrd;@a[Loc])
	
	tp @a[Loc] $Corner$
	@a[Loc] @e[type=$EntityType$,CCULocCloud] ScOP @e[c=1,r=1,type=$EntityType$,CCULocCloud] CCULCcl = @e[c=1,r=1,type=$EntityType$,CCULocCloud] CCULCnt
	@a[Loc] ScOP @e[type=$EntityType$,CCULocCloud] CCULCcl -= @a[Loc] CCULCrd
/// creates the order of (min --> max)
	@a[Loc] ScOP @e[type=$EntityType$,CCULocCloud] CCULCcl *= -1 Number
/// reverses the order to (max --> min) whereas the first nonpositive integer is the row
	
	@a[Loc] tp @a[Loc] @e[c=1,type=$EntityType$,CCULocCloud,CCULCcl<=0]
	@a[Loc] ScOP @a[Loc] CCULCcn = @e[c=1,r=1,type=$EntityType$,CCULocCloud,CCULCcl<=0] CCULCcl
	@a[Loc] ScOP @a[Loc] CCULCcn += @e[c=1,r=1,type=$EntityType$,CCULocCloud,CCULCcl<=0] CCULCnu
	@a[Loc] tp @a[Loc] ~ ~1 ~
	
	@a[Loc] CCULCab = 0
	@a[Loc] CCULCcl = 0
	
	LOOP {16 1 / 2}:
	/// fills with stone and replaces it back to update the 
		@a[Loc] fill ~ ~-1 ~ ~CALC(|0| - 1) ~-1 ~ stone 1 replace stone 2
		@a[Loc] fill ~ ~-1 ~ ~CALC(|0| - 1) ~-1 ~ stone 2 replace stone 1
		
		IF {|0| != 1}:
			@a[Loc] ScOP @a[c=1] CCULCcl = @a[c=1] CCULCab
			@a[Loc] ScOP @a[c=1] CCULCab -= @a[c=1] CCULCcn
			tp @a[Loc,CCULCab<=-1] ~|0| ~ ~
			@a[Loc,CCULCab<=-1] ScOP @a[c=1] CCULCcn -= @a[c=1] CCULCcl
			
		ELSE:
			@a[Loc] ScOP @a[c=1] CCULCab -= @a[c=1] CCULCcn
			tp @a[Loc,CCULCab<=-1] ~1 ~ ~
			
	@a[Loc] CCULCcn = 0
	@a[Loc] - Loc
//>

//<General Scoreboard End
FUNC {Func_GeneralScoreboardEnd}:
	CCU.objectiveRemove(Obj_GeneralScoreboardStart)
	kill @e[LocationEntity]
//>


//<Groups
GROUP {Grp_MainStart}:
	CCU_Deactivate(GSELF)
	Func_GeneralScoreboardStart()
	CCU_Activate(Grp_MainClock)
	CCU.tfActivate(Grp_SummonCounterTFClock)

GROUP {Grp_SummonCounterTFClock}:
	Func_SummonCounterTFClock()

GROUP {Grp_MainClock}:
	Func_GeneralScoreboardClock()

GROUP {Grp_MainEnd}:
	CCU_Deactivate(GSELF)
	Func_GeneralScoreboardEnd()
	CCU_Deactivate(Grp_MainClock)
	CCU.tfDeactivate(Grp_SummonCounterTFClock)

CCU.cmdSave()
//>







