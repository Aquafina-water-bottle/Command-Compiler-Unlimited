DEF ASDF DANK
DEF DANK MEMES 5
DEF GLOBAL aFloat 3333333333.1111111111111111111111
DEF GLOBAL COORDS $DankCoords$ 3.11 ~ 0.0000
DEF GLOBAL TELE $DankCoords$ -301 51 930.0 40 0
DEF RandNum 5
DEF ScOP scoreboard players operation
DEF $test$ ScOP @p TEST
DEF $test$ $test$ @p SPtp

DEF def1 def2
DEF def2 def3

DEF recurring_asdf aRecurringDefinition
DEF aRecurringDefinition aSecondRecurringDefinition
DEF aSecondRecurringDefinition yeah this is recurring_asdf

FUNC {GetRandFunc1}:
	say 1
	say |0|3|saytest|
	say |2|
	
FUNC {GetRandFunc2}:
	say 4
	say 5
	say 6
	
OPTIONS:
	blockOption stonebrick 0
	coordsOption 383 69 95

OPTIONS:
///	Style
///	Avaliable options: +X -X +Z -Z (and) height in y
	styleOption +X 16
///	Parse, cmd, compiler
	parseOption true
	commandOption true
	combinerOption true
	filePathFuncOption C:\Users\Austin\Documents\Austin\powder game code\eGO\Server Stuff\1.12\world\data\functions\custom
///	Filepath to MCFunctions
/// Preserve coordinates for each group
	keepCoordsOption false

///	C:\Users\Austin\Documents\Austin\powder game code\eGO\Events & Commands\CCU - Command Combiner Unlimited\test.ccu

//=
FUNC {ARGS ACTIVATE CCU.xpNumber}
	say test
=//
//(test)
MFUNC 		{BRANCH RayCaster/theHunted Main MFunc_MainRaycaster}:
	say THESE
	say ARE
	say THE
	say GREATEST
	DEF COMMANDS Dankest |0| memes |1|
	say COMMANDS(asdf;asdf2) -SPLIT- COMMANDS(more)
	say COMMANDS()
	say COMMANDS
	say asdf def1 asdf
///	say aRecurringDefinition
	say WOOOOOOOOOOOO
	
	IMPORT {LIBRARY General\utils.ccu}
	CCU.xpNumber
	
	CALL {GetRandFunc1(3;2;10;5), GetRandFunc2, GetRandFunc1, GetRandFunc1()}
	
	//=	test cond
	COND:
		ayy
		lmao
	=//
	
	//=
	comment
	block
	=//
	
	MFUNC {init MFunc_MainInit}:
		say test
		say test
		say test
		say test
		
	MFUNC {BRANCH test init MFunc_InitTest}:
		say asdf
		say asdf
		say asdf
		say asdf
		
	MFUNC {test MFunc_Test}:
		say asdf2
		say asdf2
		say asdf2
		
	MFUNC {asdf}:
		say theRealAsdf
	
	say YESSSSSSSSSSSSSSSSS
	setblock Grp_APulse air 0

GROUP {Grp_APulse}:
	say a
	say b
	function MFunc_InitTest

GROUP {PULSE Grp_B}:
	say b
	
GROUP {CLOCK Grp_C}:
	say c
	
GROUP {Grp_DClock}:
	say d
	
GROUP {Grp_E}:
	say e
	
GROUP {Grp_F}:
	say f
	
GROUP {Grp_G}:
	say g
	
GROUP {Grp_AyyLmao}:
	setblock Grp_AyyLmao air 0
	say ASDF
	say $DankCoords$[x] MARKER
	say $DankCoords$[y] MARKER
	say $DankCoords$[z] MARKER
	say $DankCoords$[ry] MARKER
	say $DankCoords$[rx] MARKER
	FUNC {UnUsedFunc}:
	say 1
	say 2
	say 3
	kill @a[anobjective=3]
	COND:
		testCond
		testCond2
	say 4
	say 5
	
	GROUP {Grp_Test2}:
		say test
		say ABORTMISSION
		DEF GLOBAL ABORTMISSION LiterallyAbortMission
		DEF $SA$ hell yeah
		/// say test
		say $SA$
		say ABORTMISSION
		lmao
		ayy
	say 6
	say 7
	say 8
	say 9
	DEF $Spam$ yas
	GROUP {Grp_Test}:
		say $SA$
		ayy
		say ABORTMISSION
		lmao
		DEF $Spam$ not_yas
		fill Grp_AyyLmao air 0
		say $Spam$
	COND:
		say ABORTMISSION
		say $SA$
		say $Spam$
		say 11
		say 12
		say 13
		say 14
	say 15
	say 16
	say 17
	
	FUNC {Func_goingToActivate}:
		say Ye
		ARGS
		TheGreatestARGS (shouldn't be considered a function)

	FUNC {ACTIVATE Func_goingToActivate ARGS}:
		say ayy
		say lmao
		
	say 18
	Func_goingToActivate
	
	
	FUNC {GLOBAL Func_goingToActivate}:
		asdfasdfsaf
		asdfae564rwe
		d45e
		78y65re7
		6756re
		
	CALL {Func_goingToActivate}

	FUNC {Recurring1}:
		Ayy
		Lmao
		Recurring2
	
	FUNC {Recurring2}:
		Ayy
		Lmao
		Recurring3
		
	FUNC {Recurring3}:
		Ayy
		Lmao
		Recurring1
	
	/// Recurring1
	
	say 19
	say 20
	say 21
	
GROUP {Grp_TheBestGroup}:
	say a
	say b
	say c
	say d
	say e
	say f
	say g
	COND:
		say h
		say i
		say j
		say k
	say l
	COND:
		say m
		say n
		say o
		say p
		say q
		say r
		say s
		say t
	
GROUP {Grp_TheGreatestGroup}:
	say 1
	USE {END asdfasdf}:
		say 2
		say 3
		say 4
		say 5
		Func_goingToActivate
		say 6
	USE {BEG asdfasdf}:
		say 7
		say 8
		say 9
		say 10
		say 11
	USE {END NOSPACE asdfasdf}:
		say 12
		say 13
		say 14
		say 15
		say 16
	USE {BEG NOSPACE asdfasdf}:
		say 17
		say 18
		USE {EncapsulatedUse}:
			say 19
			say 20
		say 21
	say 22
	say 23
	say 24
	say 25
	say 26
	
	FUNC {Func_TestDefinition}:
		say ayy
		DEF $Apparently$ say (first |0|) (second |0;1|)
		say asdf
		$Apparently$(15)
	
	Func_TestDefinition(526)
	
	FUNC {Func_TestDefinition}:
		say FIRST
		FUNC {Func_TestDefinition2}:
			say |0| |1| SECOND
			say |0;1| |1;1| FIRST
		Func_TestDefinition2(5;10)
		say test
	
	Func_TestDefinition(1;2)
	
	UNASSIGN {FUNC Func_TestDefinition}
	Func_TestDefinition
	
	say 27
	say 28
	say 29
	say 30
	say 31
	say 32
	tellraw @a {"text":"ayylmao"}
	
GROUP {BLOCK stained_hardened_clay 11 CLOCK Grp_asdf}:
	say rekt
	say rekt again
	
	/*
	say a
	b
///	c;
	d
	e
	*/
	
	say
	say
	say
	say @a
	
/// This actual mess actually parses into the correct damn thing
///	tl;dr if you don't know what you're doing with the execute shortcuts, there's pretty much no way you can mess this up
	@p ~ ~ ~ execute @a ~ ~ ~ @s @r stonebrick 0 ~ ~-1 ~ @e stonebrick * say @a
	execute @p ~ ~ ~ execute @a ~ ~ ~ execute @s ~ ~ ~ execute @r ~ ~ ~ detect ~ ~-1 ~ stonebrick 0 execute @e ~ ~ ~ detect ~ ~ ~ stonebrick * say @a
	
	execute @a ~ ~ ~ say test
	@a ~ ~ ~ say test
	@a say test
	@s @s @s kill @a[RRti>=1,testTag,kek>=1<=3]
	
	execute @a ~ ~ ~ detect ~ ~ ~ stonebrick 0 say test
	@a ~ ~ ~ detect ~ ~ ~ stonebrick 0 say test
	@a ~ ~ ~ detect stonebrick 0 say test
	@a detect ~ ~ ~ stonebrick 0 say test
	@a detect stonebrick 0 say test
	@a stonebrick 0 ~ ~ ~ say test
	@a stonebrick ~ ~ ~ say test
	@a stonebrick 0 say test
	@a stonebrick say test
	
	execute @a ~ ~ ~ detect ~ ~ ~ stonebrick * execute @a ~ ~ ~ detect ~ ~ ~ stonebrick * say test
	@a ~ ~ ~ detect ~ ~ ~ stonebrick * @a ~ ~ ~ detect ~ ~ ~ stonebrick * say test
	@a ~ ~ ~ detect stonebrick * @a ~ ~ ~ detect stonebrick * say test
	@a detect ~ ~ ~ stonebrick * @a detect ~ ~ ~ stonebrick * say test
	@a stonebrick * ~ ~ ~ @a stonebrick * ~ ~ ~ say test
	@a stonebrick * @a stonebrick * say test
	@a stonebrick @a stonebrick say test
	
	execute @a detect stonebrick 0 say test
	execute @a say test
	
/// except the following few of course
	@a not_a_block 0 say test
///	especially the following - it's just plain wrong wtf are you doing this isn't autocorrect
	execute @a ~ ~ ~ detect ~ ~ ~ stonebrick 0 ~ ~ ~ say test
	
	@e[type=ArmorStand,RRStand] ScOP @e[c=1,r=1,type=ArmorStand,RRStand] RRti = @e[c=1,r=1,type=ArmorStand,RRStand] RRti2
	@e[type=ArmorStand,RRStand] ScOP @e[c=1,r=1,type=ArmorStand,RRStand] RRti = 3 Number
	@e[type=ArmorStand,RRStand] RRti + 1 {DisabledSlots:2096896}
	@e[type=ArmorStand,RRStand] RRti - 1 {DisabledSlots:2096896}
	@e[type=ArmorStand,RRStand] RRti = 10 {DisabledSlots:2096896}
	@e[type=ArmorStand,RRStand] RRti ? RandNum
	@e[type=ArmorStand,RRStand] RRti ? 0 10
	@e[type=ArmorStand,RRStand] reset RRti
	@e[type=ArmorStand,RRStand] enable RRti
	@e[type=ArmorStand,RRStand] + RRTimer {Marker:1b}
	@e[type=ArmorStand,RRStand] - RRTimer {Marker:1b}
	RRd_y J> @e[type=ArmorStand,RRStand]
	RRd_y L> @e[type=ArmorStand,RRStand]
	RRd_y E>
	
	USE {@a}:
		@e[type=ArmorStand,RRStand] ScOP @e[c=1,r=1,type=ArmorStand,RRStand] RRti = @e[c=1,r=1,type=ArmorStand,RRStand] RRti2
		@e[type=ArmorStand,RRStand] ScOP @e[c=1,r=1,type=ArmorStand,RRStand] RRti = 3 Number
		@e[type=ArmorStand,RRStand] RRti + 1 {DisabledSlots:2096896}
		@e[type=ArmorStand,RRStand] RRti - 1 {DisabledSlots:2096896}
		@e[type=ArmorStand,RRStand] RRti = 10 {DisabledSlots:2096896}
		@e[type=ArmorStand,RRStand] RRti ? RandNum
		@e[type=ArmorStand,RRStand] RRti ? 0 10
		@e[type=ArmorStand,RRStand] reset RRti
		@e[type=ArmorStand,RRStand] enable RRti
		@e[type=ArmorStand,RRStand] + RRTimer {Marker:1b}
		@e[type=ArmorStand,RRStand] - RRTimer {Marker:1b}
		RRd_y J> @e[type=ArmorStand,RRStand]
		RRd_y L> @e[type=ArmorStand,RRStand]
		RRd_y E>
	
	ayylmao RRti + 1 {DisabledSlots:2096896}
	ayylmao RRti - 1 {DisabledSlots:2096896}
	ayylmao RRti = 10 {DisabledSlots:2096896}
	ayylmao RRti ? 3
	ayylmao RRti ? 0 10
	ayylmao reset RRti
	ayylmao enable RRti
	ayylmao + RRTimer {Marker:1b}
	ayylmao - RRTimer {Marker:1b}
	RRd_y J> ayylmao
	RRd_y L> ayylmao
	RRd_y E>
	
	tellraw @a[TSToken>=1,SPtsc<=1,SPtsn=10] {"text":"","extra"[{"text":"You have submitted 10 incorrect answers, and have 0 tries left.","color":"gray"}]}
	scoreboard players operation @p SPtp = 3 Number
	
	DEF $SA$ x=-153,y=0,z=299,dx=158,dy=110,dz=168
	tellraw @a {"selector":"@a[$SA$,asdf=5]"}
	effect @a[$SA$,m=2,RRci=0,RRar=1] 11 1 0 true
	effect @a[$SA$,m=2,RRci=0,RRar>=1<=2] 7 1 1 true
	
	say @a[name>=3<=5] @a[name>=3<5] @a[name>=3]
	say @a[name<=5>=3] @a[name<=5>3] @a[name<=3]
	say @a[name>3<=5] @a[name>3<5] @a[name>3]
	say @a[name<5>=3] @a[name<5>3] @a[name<3]
	
	$test$
	
	DEF $test$ say test
	DEF $test$ say test2
	
	$test$
	UNASSIGN {DEF $test$}
	$test$
	UNASSIGN {DEF $test$}
	$test$
	
	FUNC {GLOBAL Func_AyyLmao}:
		say ayy
		say lmao
		
	Func_AyyLmao
	
	FUNC {Func_AyyLmao}:
		say lmao compared to ayy
	
	Func_AyyLmao
	
	UNASSIGN {FUNC GLOBAL Func_AyyLmao}
	Func_AyyLmao
	
///	the following will result in an error
///	say @a[name>=3>5]
///	say @a[name<=3<5]
///	say @a[name>5>=3]
///	say @a[name<5<=3]

	fill Grp_asdf air 0
	
	//=
	LOOP {20 21 + 1}:
		LOOP {1 2 + 1} {5 7 + 1}:
			LOOP {10 8 - 1}:
				say 0--> |0;1| 1--> |1;1| 2--> |0| EXTRA--> |0;2|
	
	LOOP {20 21 + 1}:
		LOOP {1 2 + 1} {5 7 + 1}:
			say 0--> |0| 1--> |1| 2--> 10 EXTRA--> |0;1|
			say 0--> |0| 1--> |1| 2--> 9 EXTRA--> |0;1|
			say 0--> |0| 1--> |1| 2--> 8 EXTRA--> |0;1|
	
	LOOP {20 21 + 1}:
		say 0--> 1 1--> 5 2--> 10 EXTRA--> |0|
		say 0--> 1 1--> 5 2--> 9 EXTRA--> |0|
		say 0--> 1 1--> 5 2--> 8 EXTRA--> |0|
		say 0--> 2 1--> 6 2--> 10 EXTRA--> |0|
		say 0--> 2 1--> 6 2--> 9 EXTRA--> |0|
		say 0--> 2 1--> 6 2--> 8 EXTRA--> |0|
		say 0-->  1--> 7 2--> 10 EXTRA--> |0|
		say 0-->  1--> 7 2--> 9 EXTRA--> |0|
		say 0-->  1--> 7 2--> 8 EXTRA--> |0|
	
	
	
	
	
	
	
	
	
	LOOP 1 2 + 1 () 5 7 + 1
		LOOP 10 8 - 1
			say 0--> |0||1| 1--> |2||1| 2--> |0|
		END
	END
	
	say 0--> 1 1--> 5 2--> 10
	say 0--> 1 1--> 5 2--> 9
	say 0--> 1 1--> 5 2--> 8
	say 0--> 2 1--> 6 2--> 10
	say 0--> 2 1--> 6 2--> 9
	say 0--> 2 1--> 6 2--> 8
	say 0--> 1--> 7 2--> 10
	say 0--> 1--> 7 2--> 9
	say 0--> 1--> 7 2--> 8
	
	
	=//
