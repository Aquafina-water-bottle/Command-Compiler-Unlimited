//(Name)
CCU.isImport(Coordinates/randLoc)

//==
Ideas from:
	Shane Stone for providing the basis on how everything is done
	Shane Stone's Youtube Channel: https://www.youtube.com/user/shanewolf38/featured
	Video explanation: https://www.youtube.com/watch?v=9jZpheCdkqM
=//

//=
DEF $StyleDirection$ +X
DEF COORDS $CoordsOption$ 233 7 174
DEF $BlockOption$ stonebrick 0

IMPORT {LIBRARY GETDIR 1.10/General}
IMPORT {LIBRARY 1.10/Math/random.ccu}

OPTIONS:
	blockOption $BlockOption$
	coordsOption $CoordsOption$
	styleOption $StyleDirection$ 16
	parseOption true
	commandOption true
	combinerOption true
	parseChangesOption false
		
FUNC {ACTIVATE CCU.coordinates.randLoc() ARGS}:
	DEF COORDS $Corner$ 233 5 181
	DEF COORDS $FillRegion$ 233 4 181 258 4 217
	DEF $RowNumber$ 37
	DEF $ColumnNumber$ 26

	DEF $EntityType$ AreaEffectCloud /// change to ArmorStand for debugging purposes
	
	DEF $CCUrandLocObjNum$ CCULCnu
	DEF $CCUrandLocObjTot$ CCULCnt
	DEF $CCUrandLocObjAffectedBlocks$ CCULCab
	DEF $CCUrandLocObjTeleNum$ CCULCtn
	DEF $CCUrandLocObjRand$ CCULCrd
	DEF $CCUrandLocObjCalc$ CCULCcl
	DEF $CCUrandLocObjChooseNum$ CCULCcn
	DEF $CCUrandLocObjConst$ Number
	DEF $CCUrandLocSelector$ @a[Loc]
	
	ARRAY GLOBAL {Arr_CCUrandLocCloudTags}:
		CCURandLocCloud
		
	ARRAY GLOBAL {Arr_CCUrandLocStandTags}:
		CCURandLocStand
=//

//<Initialize
FUNC {CCU.coordinates.randLocInitialize}:
	ARGS()
	UNASSIGN {FUNC ARGS}
	
	IF {$CCUObjNum$ = `$CCUObjX$`}:
		PRINT $CCUObjX$ under CCU.coordinates.randLocInitialize will default to CCUCDpx
		DEF GLOBAL $CCUObjX$ CCUCDpx
	
	IF {$CCUObjY$ = `$CCUObjY$`}:
		PRINT $CCUObjY$ under CCU.coordinates.randLocInitialize will default to CCUCDpy
		DEF GLOBAL $CCUObjY$ CCUCDpy
	
	IF {$CCUObjZ$ = `$CCUObjZ$`}:
		PRINT $CCUObjZ$ under CCU.coordinates.randLocInitialize will default to CCUCDpz
		DEF GLOBAL $CCUObjZ$ CCUCDpz
	
	IF {$CCUObjTPX$ = `$CCUObjTPX$`}:
		PRINT $CCUObjTPX$ under CCU.coordinates.randLocInitialize will default to CCUCDtx
		DEF GLOBAL $CCUObjTPX$ CCUCDtx
	
	IF {$CCUObjTPY$ = `$CCUObjTPY$`}:
		PRINT $CCUObjTPY$ under CCU.coordinates.randLocInitialize will default to CCUCDty
		DEF GLOBAL $CCUObjTPY$ CCUCDty
	
	IF {$CCUObjTPZ$ = `$CCUObjTPZ$`}:
		PRINT $CCUObjTPZ$ under CCU.coordinates.randLocInitialize will default to CCUCDtz
		DEF GLOBAL $CCUObjTPZ$ CCUCDtz
	
	IF {$CCUObjStats$ = `$CCUObjStats$`}:
		PRINT $CCUObjStats$ under CCU.coordinates.randLocInitialize will default to CCUCDst
		DEF GLOBAL $CCUObjStats$ CCUCDst
	
	IF {Arr_CCUCloudTags[S] = `Arr_CCUCloudTags[S]`}:
		PRINT Arr_CCUCloudTags under CCU.coordinates.randLocInitialize will default to CCUGetCoordsCloud
		ARRAY {GLOBAL Arr_CCUCloudTags}:
			CCUGetCoordsCloud
	
	IF {$CCUFolderName$ = `$CCUFolderName$`}:
		PRINT $CCUFolderName$ under CCU.coordinates.randLocInitialize will default to coordinates
		DEF GLOBAL $CCUFolderName$ coordinates
	
	IF {$CCUNumber$ = `$CCUNumber$`}:
		PRINT $CCUNumber$ under CCU.coordinates.randLocInitialize will default to Number
		DEF GLOBAL $CCUNumber$ Number
//>

//<General Scoreboard Start
FUNC {Func_GeneralScoreboardStart}:
	ARRAY {GLOBAL ACTIVATE CCU.objectiveAdd(Obj_GeneralScoreboardStart) Obj_GeneralScoreboardStart}:
		CCULCnu dummy Location Number
		CCULCnt dummy Location Number Total
		CCULCab dummy Location Affected Blocks
		CCULCtn dummy Location Teleport Number
		CCULCrd dummy Location Random
		CCULCcl dummy Location Calc
		CCULCcn dummy Location Choose Num
	
	ARRAY {ACTIVATE CCU.iterateNumbers() ARGS}:
		-1
		
	summon ArmorStand $Corner$[x, y - 1, z] {Tags:["LocationEntity","CCULocStand"],Invulnerable:1,PersistenceRequired:1,Marker:1,NoGravity:1}
	@a stats entity @a[c=1] set AffectedBlocks @a[c=1] CCULCab
	@e[type=ArmorStand,CCULocStand] CCULCab = 0
	@e[type=ArmorStand,CCULocStand] CCULCtn = 0
	@e[type=ArmorStand,CCULocStand] stats entity @e[c=1,type=ArmorStand,CCULocStand] set AffectedBlocks @e[c=1,type=ArmorStand,CCULocStand] CCULCab
	
	FUNC {ACTIVATE CCU.random.init(1;CCULCrd) ARGS}:
		DEF $CCUDynamicMin$ false
		DEF $CCUDynamicMax$ true
		DEF $CCURandMin$ 1
		DEF $CCURandMax$ 5
		
	ScSS CCULCrd
//>

//<Summon Counter Testfor Clock
FUNC {Func_SummonCounterTFClock}:
	testfor @e[type=ArmorStand,CCULocStand,CCULCtn>=0]
	CCU_SetblockTestfor
	
	@e[type=ArmorStand,CCULocStand,CCULCtn>=0] summon $EntityType$ ~ ~ ~ {Tags:["LocationEntity","CCULocCloud"],$Duration$}
	@e[type=$EntityType$,CCULocCloud] CCULCnt + 0 /// initialize CCULCnt
	@e[type=ArmorStand,CCULocStand,CCULCtn>=0] fill ~ ~ ~ ~CALC($ColumnNumber$ - 1) ~ ~ stone 1 replace stone 2 /// gets the number of granite in the row
	@e[type=ArmorStand,CCULocStand,CCULCtn>=0,CCULCab=0] kill @e[type=$EntityType$,CCULocCloud,CCULCnt=0] /// removes the cloud if there are no granite
	ScOP @e[type=$EntityType$,CCULocCloud,CCULCnt=0] CCULCnu += @e[type=ArmorStand,CCULocStand,CCULCtn>=0] CCULCab /// adds to the current number
	ScOP @e[type=ArmorStand,CCULocStand,CCULCtn>=0] CCULCnt += @e[type=ArmorStand,CCULocStand,CCULCtn>=0] CCULCab /// adds to the total
	ScOP @e[type=$EntityType$,CCULocCloud,CCULCnt=0] CCULCnt = @e[type=ArmorStand,CCULocStand,CCULCtn>=0] CCULCnt /// sets the cloud to the current total
	
	@e[type=ArmorStand,CCULocStand,CCULCtn>=0] CCULCtn + 1 /// adds the row number
	tp @e[type=ArmorStand,CCULocStand,CCULCtn>=0] ~ ~ ~1 /// teleports one to the -Z
	
///	Assuming that the armor stand has reached the max row number:
	ScOP Max CCULCrd = @e[type=ArmorStand,CCULocStand,CCULCtn=$RowNumber$] CCULCnt /// Sets the max number in CCULCrd as the number of granite
	@e[type=ArmorStand,CCULocStand,CCULCtn=$RowNumber$] fill $FillRegion$ stone 2 replace stone 1 /// Resets all stone
	@e[type=ArmorStand,CCULocStand,CCULCtn=$RowNumber$] CCULCtn = -1 /// Sets CCULCtn to -1
//>

//<General Scoreboard Clock
FUNC {Func_GeneralScoreboardClock}:
	testfor @a[Loc]
	CCU_SetblockTestfor
	
	FUNC {ARGS}:
		DEF $CCUDynamicMin$ false
		DEF $CCUDynamicMax$ true
		DEF $CCURandMin$ 1
	
	USE {@a[Loc]}:
		CCU.random.main(1;CCULCrd;@a[Loc])
	
	tp @a[Loc] $Corner$
	@a[Loc] @e[type=$EntityType$,CCULocCloud] ScOP @e[c=1,r=1,type=$EntityType$,CCULocCloud] CCULCcl = @e[c=1,r=1,type=$EntityType$,CCULocCloud] CCULCnt
	@a[Loc] ScOP @e[type=$EntityType$,CCULocCloud] CCULCcl -= @a[Loc] CCULCrd
/// creates the order of (min --> max)
	@a[Loc] ScOP @e[type=$EntityType$,CCULocCloud] CCULCcl *= -1 Number
/// reverses the order to (max --> min) whereas the first nonpositive integer is the row
	
	@a[Loc] tp @a[Loc] @e[c=1,type=$EntityType$,CCULocCloud,CCULCcl<=0]
	@a[Loc] ScOP @a[Loc] CCULCcn = @e[c=1,r=1,type=$EntityType$,CCULocCloud,CCULCcl<=0] CCULCcl
	@a[Loc] ScOP @a[Loc] CCULCcn += @e[c=1,r=1,type=$EntityType$,CCULocCloud,CCULCcl<=0] CCULCnu
	@a[Loc] tp @a[Loc] ~ ~1 ~
	
	@a[Loc] CCULCab = 0
	@a[Loc] CCULCcl = 0
	
	LOOP {16 1 / 2}:
	/// fills with stone and replaces it back to update the 
		@a[Loc] fill ~ ~-1 ~ ~CALC(|0| - 1) ~-1 ~ stone 1 replace stone 2
		@a[Loc] fill ~ ~-1 ~ ~CALC(|0| - 1) ~-1 ~ stone 2 replace stone 1
		
		IF {|0| != 1}:
			@a[Loc] ScOP @a[c=1] CCULCcl = @a[c=1] CCULCab
			@a[Loc] ScOP @a[c=1] CCULCab -= @a[c=1] CCULCcn
			tp @a[Loc,CCULCab<=-1] ~|0| ~ ~
			@a[Loc,CCULCab<=-1] ScOP @a[c=1] CCULCcn -= @a[c=1] CCULCcl
			
		ELSE:
			@a[Loc] ScOP @a[c=1] CCULCab -= @a[c=1] CCULCcn
			tp @a[Loc,CCULCab<=-1] ~1 ~ ~
			
	@a[Loc] CCULCcn = 0
	@a[Loc] - Loc
//>

//<General Scoreboard End
FUNC {Func_GeneralScoreboardEnd}:
	CCU.objectiveRemove(Obj_GeneralScoreboardStart)
	kill @e[type=AreaEffectCloud,]
//>


//<Groups
GROUP {Grp_MainStart}:
	CCU_Deactivate(GSELF)
	Func_GeneralScoreboardStart()
	CCU_Activate(Grp_MainClock)
	CCU.tfActivate(Grp_SummonCounterTFClock)

GROUP {Grp_SummonCounterTFClock}:
	Func_SummonCounterTFClock()

GROUP {Grp_MainClock}:
	Func_GeneralScoreboardClock()

GROUP {Grp_MainEnd}:
	CCU_Deactivate(GSELF)
	Func_GeneralScoreboardEnd()
	CCU_Deactivate(Grp_MainClock)
	CCU.tfDeactivate(Grp_SummonCounterTFClock)

CCU.cmdSave()
//>







