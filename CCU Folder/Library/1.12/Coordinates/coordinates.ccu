//(Coordinates to scoreboard)
//=
Ideas from:
	For getting the Y coordinates and teleporting
	King Cat: https://www.youtube.com/channel/UCwTnzVfIIvN_a8mYOvTfAcA
	Video: https://youtu.be/gYEa0NGvgHY
	
	For getting the X and Z coordinates
	DoubleJGames: https://www.reddit.com/r/Minecraft/comments/6id4k0/112_coordinate_finder_function/
	Download: https://www.dropbox.com/s/ws9snxe6q7pfpck/coordDetect.zip?dl=0
=//

//=
IMPORT {LIBRARY GETDIR 1.12/General}
IMPORT {LIBRARY 1.12/Coordinates/coordinates.ccu}

OPTIONS:
	parseOption true
	commandOption true
	combinerOption true
	filePathFuncOption C:\Users\Austin\Documents\Austin\powder game code\eGO\Server Stuff\1.12.1\world\data\functions\french_man
	deleteFunctionFolderOption true
		
FUNC {ACTIVATE CCU.coordinatesToScoreboard() ARGS}:
	DEF $CCUObjX$ CDpx
	DEF $CCUObjY$ CDpy
	DEF $CCUObjZ$ CDpz
	DEF $CCUObjTPX$ CDclx
	DEF $CCUObjTPY$ CDcly
	DEF $CCUObjTPZ$ CDclz
	DEF $CCUObjStats$ CDst
	DEF $CCUFolderName$ coordinates
	DEF $CCUNumber$ Number

	ARRAY {Arr_CCUCloudTags}:
		GetCoordsCloud
=//

//<Initialize
FUNC {CCU.coordinatesToScoreboard}:
	ARGS()
	UNASSIGN {FUNC ARGS}
	
	IF {$CCUObjX$ = `$CCUObjX$`}:
		EXIT $CCUObjX$ must be defined when using CCU.coordinatesToScoreboard
	
	IF {$CCUObjY$ = `$CCUObjY$`}:
		EXIT $CCUObjY$ must be defined when using CCU.coordinatesToScoreboard
	
	IF {$CCUObjZ$ = `$CCUObjZ$`}:
		EXIT $CCUObjZ$ must be defined when using CCU.coordinatesToScoreboard
	
	IF {$CCUObjTPX$ = `$CCUObjTPX$`}:
		EXIT $CCUObjTPX$ must be defined when using CCU.coordinatesToScoreboard
	
	IF {$CCUObjTPY$ = `$CCUObjTPY$`}:
		EXIT $CCUObjTPY$ must be defined when using CCU.coordinatesToScoreboard
	
	IF {$CCUObjTPZ$ = `$CCUObjTPZ$`}:
		EXIT $CCUObjTPZ$ must be defined when using CCU.coordinatesToScoreboard
	
	IF {$CCUObjStats$ = `$CCUObjStats$`}:
		EXIT $CCUObjStats$ must be defined when using CCU.coordinatesToScoreboard

	IF {Arr_CCUCloudTags[S] = `Arr_CCUCloudTags[S]`}:
		EXIT Arr_CCUCloudTags must be defined when using CCU.coordinatesToScoreboard
	
	IF {$CCUFolderName$ = `$CCUFolderName$`}:
		DEF GLOBAL $CCUFolderName$ coordinates
	
	IF {$CCUNumber$ = `$CCUNumber$`}:
		DEF GLOBAL $CCUNumber$ Number
//>

//<Calculating variables
	///	calculating the first tag
	DEF $CCUFirstTagCalc$ Arr_CCUCloudTags[0]

	/// worldborder radius
	DEF $CCUWorldBorderRadius$ 30000000

	/// Calculating the biggest power of 2 required for ($CCUWorldBorderRadius$ * 2)
	DEF $CCUCalcLog$ CALC(LOG(DEC($CCUWorldBorderRadius$ * 2)) / LOG(2.0))
	CCU.roundDown($CCUCalcLog$;`$CCUCalcLog$`)
	DEF $CCUMaxPowerX$ $CCUCalcLog$
	DEF $CCUMaxPowerY$ 12 /// 4096
	DEF $CCUMaxPowerZ$ $CCUCalcLog$

	///	To make sure that coordinates are placed correctly
	DEF $CCURelativeX$ ~|0| ~ ~
	DEF $CCURelativeY$ ~ ~|0| ~
	DEF $CCURelativeZ$ ~ ~ ~|0|
//>

//<Minecraft Functions
	///	A branch is used for $CCUFolderName$
	MFUNC {BRANCH $CCUFolderName$ init MFunc_Init}:
		ARRAY {GLOBAL ACTIVATE CCU.objectiveAdd(Obj_GeneralScoreboardStart) Obj_GeneralScoreboardStart}:
			$CCUObjX$ dummy
			$CCUObjY$ dummy
			$CCUObjZ$ dummy
			$CCUObjTPX$ dummy
			$CCUObjTPY$ dummy
			$CCUObjTPZ$ dummy
			$CCUObjStats$ dummy
			
		ARRAY {ACTIVATE CCU.iterateNumbers() ARGS}:
			-1
			
	///	teleports relative to the given player as the score number
	///	uses a binary search to do so
		LOOP {X;Y;Z}:
			MFUNC {teleport_pos|0| MFunc_TPPos|0|}:
				LOOP {(2 ^ $CCUMaxPower|0|$) 1 / 2}:
					@s[$CCUObjTP|0;1|$>=|0|] tp @s $CCURelative|0;1|$(|0|)
					@s[$CCUObjTP|0;1|$>=|0|] $CCUObjTP|0;1|$ - |0|
					
			MFUNC {teleport_neg|0| MFunc_TPNeg|0|}:
				LOOP {(2 ^ $CCUMaxPower|0|$) 1 / 2}:
					@s[$CCUObjTP|0;1|$<=-|0|] tp @s $CCURelative|0;1|$(-|0|)
					@s[$CCUObjTP|0;1|$<=-|0|] $CCUObjTP|0;1|$ + |0|

	///	specifically for the Y value, stats entity must be used
	//=	how this works:
		-summons area_effect_cloud, adds stats to SuccessCount
		-Adds player to $CCUObjStats$, and will reset later to prevent mismatching
		-uses a binary search to teleport the area_effect_cloud to the max height, which is 4096
		-normally, the cloud cannot teleport past 4096, it gets the total distance between the player and 4096
		-it then minuses the entire score by 4096 and multiplies by -1
		-kills area_effect_cloud and resets $CCUObjStats$
	=//

		MFUNC {get_posY MFunc_GetY}:
			@s $CCUObjY$ = 0
			summon area_effect_cloud ~ ~ ~ {Duration:5,Tags:[;
			CCU.scoreboardTags(Arr_CCUCloudTags)
			]}
			
			@s $CCUObjStats$ + 0
			stats entity @e[type=area_effect_cloud,$CCUFirstTagCalc$] set SuccessCount @e[c=1,$CCUObjStats$>=0] $CCUObjStats$
			
			LOOP {(2 ^ $CCUMaxPowerY$) 1 / 2}:
				@e[$CCUFirstTagCalc$] tp @s ~ ~|0| ~
				@s[$CCUObjStats$>=1] $CCUObjY$ + |0|
			
			@s $CCUObjY$ - 4096
			@s reset $CCUObjStats$
			ScOP @s $CCUObjY$ *= -1 Number
			
			kill @e[type=area_effect_cloud,$CCUFirstTagCalc$]
			
	///	specifically for the X and Z value, a simple execute can be used
	//=	how this works:
		-summons area_effect_cloud and does a calc value function on it
		-uses a binary search to teleport the area_effect_cloud to the max X/Z distance, which is 30000000
		-instead of teleporting, it executes at the given X or Z distance to see if it can run a command there
		-it will eventually get the full distance the player is away from the worldborder
		-it then minuses the entire score by (30000000 - 1) and multiplies by -1
		-kills area_effect_cloud
	=//
		LOOP {X;Z}:
			MFUNC {get_pos|0| MFunc_Get|0|}:
				@s $CCUObj|0|$ = 0
				summon area_effect_cloud ~ ~ ~ {Duration:5,Tags:[;
				CCU.scoreboardTags(Arr_CCUCloudTags)
				]}
				
			///	a new function is called to use @s instead of @e as much as possible
				@e[type=area_effect_cloud,$CCUFirstTagCalc$] MFunc_Calc|0|
				MFUNC {calc_pos|0| MFunc_Calc|0|}:
					LOOP {(2 ^ $CCUMaxPower|0|$) 1 / 2}:
						@s $CCURelative|0;1|$(|0|) @s $CCUObj|0;1|$ + |0|
						@s $CCURelative|0;1|$(|0|) tp @s $CCURelative|0;1|$(|0|)
					
					@s $CCUObj|0|$ - CALC($CCUWorldBorderRadius$ - 1)
					ScOP @s $CCUObj|0|$ *= -1 Number
				
				ScOP @s $CCUObj|0|$ = @e[type=area_effect_cloud,$CCUFirstTagCalc$] $CCUObj|0|$
				kill @e[type=area_effect_cloud,$CCUFirstTagCalc$]

		MFUNC {teleport MFunc_Teleport}:	
			LOOP {X;Y;Z}:
				@e[$CCUObjTP|0|$>=1] MFunc_TPPos|0|
				@e[$CCUObjTP|0|$<=-1] MFunc_TPNeg|0|
		
		
		MFUNC {display_coords MFunc_DispCoords}:
			MFunc_GetX
			MFunc_GetY
			MFunc_GetZ
			/*
			title @s actionbar {"text":"","extra":[
				{"text":"X --> ","color":"gold"},
				{"score":{"name":"@s","objective":"$CCUObjX$"},"color":"green"},
				{"text":" Y --> ","color":"gold"},
				{"score":{"name":"@s","objective":"$CCUObjY$"},"color":"green"},
				{"text":" Z --> ","color":"gold"},
				{"score":{"name":"@s","objective":"$CCUObjZ$"},"color":"green"}
			]}
			*/
			
		MFUNC {uninstall MFunc_Uninstall}:
			CCU.objectiveRemove(Obj_GeneralScoreboardStart)

	UNASSIGN {DEF $CCUFirstTagCalc$}
	UNASSIGN {DEF $CCUWorldBorderRadius$}
	UNASSIGN {DEF $CCUCalcLog$}
	UNASSIGN {DEF $CCUMaxPowerX$}
	UNASSIGN {DEF $CCUMaxPowerY$}
	UNASSIGN {DEF $CCUMaxPowerZ$}
	UNASSIGN {DEF $CCURelativeX$}
	UNASSIGN {DEF $CCURelativeY$}
	UNASSIGN {DEF $CCURelativeZ$}
//>






